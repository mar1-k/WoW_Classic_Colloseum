import os
import re
from datetime import datetime, timedelta
from google.cloud import storage, bigquery


class match:
    def __init__(self,file_name,log_path):
        self.file_name = file_name
        self.match_id = re.search(r'([a-f0-9]{64})\.txt$', file_name).group(1)  #Unique match_id for this arena game, found in file name, generated by the log parser that generated the arena log
        self.arena_map = re.search(r'_(\w+_\w+)_([a-f0-9]{64})\.txt$', file_name).group(1) #The zone of that the arena match was fought in [[Nagrand Arena", "Ruins of Lordaeron", "Dalaran Arena", "Blade's Edge Arena"]
        self.combat_log = log_path
        self.log_process_timestamp = None #The timestamp that the log for this game was processed at
        self.last_death_event = None #The last death logline, keeping in memory to determine winner once teams are determined
        self.match_start_time = None #Timestamp determined based on first event in the log + 45 seconds
        self.match_end_time = None #Timestamp determined based on the last death in the log
        self.match_length = 0 #Length of the arena game (in seconds)
        self.players = {} #The players in this game, can be 4 (2v2), 6(3v3), or 10(5v5) players. This is a dict where the key is the player id and values is a set of flags
        self.team_1 = set() #The set of players on team 1, typically the team of the uploader (probably), can be 2, 3, or 5 players, uses player objects
        self.team_1_comp = None #The arena team composition of team_1, e.g: [restoration_shaman, unholy_deathknight], [subtlety_rogue, frost_mage, discipline_priest]
        self.team_2 = set()   #The set of players on team 2, typically the team of the uploader (probably), can be 2, 3, or 5 players 
        self.team_2_comp = None #The arena team composition of team_2, e.g: [restoration_shaman, unholy_deathknight], [subtlety_rogue, frost_mage, discipline_priest]
        self.game_type = None #The format of the arena game (2v2, 3v3, or 5v5)
        self.winner = "Unknown" #The team that won the match, this is determined based on the team of the last person to die in the log

    def to_dict(self):
        team_1_player_list = []
        team_2_player_list = []

        team_1_player_details = []
        team_2_player_details = []

        # Sort the team members by name
        sorted_team_1 = sorted(self.team_1, key=lambda player: player.name)
        sorted_team_2 = sorted(self.team_2, key=lambda player: player.name)

        for team_member in sorted_team_1:
            team_1_player_list.append(team_member.name + " | " + team_member.played_spec + " " + team_member.player_class)
            team_1_player_details.append(team_member.to_dict())

        for team_member in sorted_team_2:
            team_2_player_list.append(team_member.name + " | " + team_member.played_spec + " " + team_member.player_class)
            team_2_player_details.append(team_member.to_dict())

        return {
            'match_id': self.match_id,
            'match_log' : self.combat_log,
            'arena_map': self.arena_map,
            'game_type': self.game_type,
            'match_start_time': self.match_start_time.strftime('%m-%d %H:%M:%S') + ' in timezone of uploader',
            'match_end_time': self.match_end_time.strftime('%m-%d %H:%M:%S') + ' in timezone of uploader',
            'match_length' : self.match_length,
            'log_process_timestamp': self.log_process_timestamp,
            'team_1' :  team_1_player_list,
            'team_2' : team_2_player_list,
            'winner' : self.winner,
            'team_1_player_details' : team_1_player_details,
            'team_2_player_details' : team_2_player_details
        }
    

class player:
    def __init__(self):
        self.name = None #Name of the player e.g 'Pushbackk-Benediction'
        self.player_id = None #ID of the player e.g 'Player-4728-0561A69A'
        self.flags = set() #Set of flags ascribed to this player this game, used to determine team
        self.player_class = None #Class of the player e.g 'Rogue'
        self.played_spec = None #Spec of the player e.g 'Subtlety'
        self.team = None #Team of the player for this game e.g 'team_1'
        self.winner = False #Flag for whether this player's team won this match
        self.damage = 0 #Player's damage done this match
        self.damage_taken = 0 #Player damage taken this match
        self.pet_damage = 0 #Player's pet damage this match
        self.interrupts = 0 #Player's number of succesful interrupts this match
        self.crowd_control = 0 #Player's number of crowd_controls this match
        self.crowd_control_duration = 0 #Length of time players of other team CC'd by this player (in seconds)
        self.purges = 0 #Number of buffs this player has removed from the other team this game
        self.healing = 0 #Player's healing this match        
        self.dispels = 0 #Number of debuffs this player has removed from their team this game
        self.interrupted = 0 #Number of times this player was interrupted this game
        self.interrupted_duration = 0 #Duration this player was interrupted for their main spell school this match (in seconds)
        self.fake_casts = 0 #Number of times the player has succesfully fake casted an opponent this game
        self.crowd_controlled_duration = 0 #Duration this player was CC'd by the other team this game (in seconds)
        self.misses = 0

    def to_dict(self):
        return {
            'player_name' : self.name,
            'player_id' : self.player_id,
            'player_class' : self.player_class,
            'played_spec' : self.played_spec,
            'player_damage_done' : self.damage,
            'player_damage_taken' :self.damage_taken,
            'pet_damage' : self.pet_damage,
            'interrupts' : self.interrupts,
            'crowd_control' : self.crowd_control,
            'crowd_control_duration' : self.crowd_control_duration,
            'purges' : self.purges,
            'healing' : self.healing,
            'dispels' : self.dispels,
            'interrupted_duration' : self.interrupted_duration,
            'fake_casts' : self.fake_casts,
            'crowd_controlled_duration' : self.crowd_controlled_duration,
            'misses' : self.misses
        }

def get_timestamp_from_log_line(log_line):
    timestamp_parts = log_line.split(',')[0].split(' ')
    date_parts = timestamp_parts[0].split('/')
    time_parts = timestamp_parts[1].split(':')
    year = datetime.now().year #Assuming that the game was played this year, as WoW Combat logs dont log the year
    month = date_parts[0]
    day = date_parts[1]
    time = time_parts[0] + '.' + time_parts[1] + '.' + time_parts[2]
    timestamp = f"{year}-{month}-{day}_{time}"
    timestamp_format = "%Y-%m-%d_%H.%M.%S.%f"
    timestamp = datetime.strptime(timestamp, timestamp_format)
    return timestamp

def process_arena_log(game_log, file_name, log_path):

    #Function to extract players and their flags from the combat log
    def extract_players(game_log):
        player_dict = {}
        pattern = r'(Player-\d+-[0-9A-F]+),"([^"]+)",0x([0-9A-F]+)'
        for line in game_log:
            if "SPELL_CAST_SUCCESS" in line:
                regex_matches = re.findall(pattern, line)
                if regex_matches:
                    for regex_match in regex_matches:
                        key = regex_match[0] + '|' + regex_match[1]
                        if key in player_dict: #Add Flags to pre-existing player entry
                            player_dict[key].add(regex_match[2])
                        else: #Create a new set and dict entry
                            flags = set()
                            flags.add(regex_match[2])
                            player_dict[key] = flags

        return player_dict
    
    #Function to extract teams from the players dictionary, instatiates the player objects on the teams
    def extract_teams(players, game_log):

        team_1 = set()
        team_2 = set()

        #Start building player objects for each player
        for participant in players.items():
            p = player()
            p.player_id = participant[0].split('|')[0]
            p.name = participant[0].split('|')[1]
            p.flags = participant[1]
            p.player_class, p.played_spec = get_player_class_and_spec(p.player_id,game_log)

            #Determine player team based on flags:
            if ('511' in p.flags) or ('512' in p.flags):
                p.team = "team_1"
                team_1.add(p)
            else:
                p.team = "team_2"
                team_2.add(p)

        return team_1, team_2


    '''
    Infers player class and specialization from the game log.
    Parameters:
    player_id (str): The player ID to extract values for
    game_log (str): The game log containing player actions and events.
    Returns:
    dict: A dictionary with player names as keys and a tuple (class, spec) as values.
    '''
    def get_player_class_and_spec(player_id, game_log):

        inferred_class = "Unknown"
        inferred_spec = "Unknown"

        #This is a really bad way of doing this, but itll do for now
        spell_dict = {
            "Blood Shield": ("Death Knight", "Blood"),
            "Rune Tap": ("Death Knight", "Blood"),
            "Vampiric Blood": ("Death Knight", "Blood"),
            "Crimson Scourge": ("Death Knight", "Blood"),
            "Bone Shield": ("Death Knight", "Blood"),
            "Dancing Rune Weapon": ("Death Knight", "Blood"),
            "Frost Strike": ("Death Knight", "Frost"),
            "Improved Icy Talons" : ("Death Knight", "Frost"),
            "Obliterate": ("Death Knight", "Frost"),
            "Howling Blast": ("Death Knight", "Frost"),
            "Pillar of Frost": ("Death Knight", "Frost"),
            "Hungering Cold": ("Death Knight", "Frost"),
            "Scourge Strike": ("Death Knight", "Unholy"),
            "Ebon Plague": ("Death Knight", "Unholy"),
            "Festering Strike": ("Death Knight", "Unholy"),
            "Unholy Blight": ("Death Knight", "Unholy"),
            "Summon Gargoyle": ("Death Knight", "Unholy"),
            "Anti-Magic Zone": ("Death Knight", "Unholy"),
            "Dark Transformation": ("Death Knight", "Unholy"),
            "Moonkin Aura": ("Druid", "Balance"),
            "Moonkin Form": ("Druid", "Balance"),
            "Starfall": ("Druid", "Balance"),
            "Eclipse (Solar)" : ("Druid", "Balance"),
            "Eclipse (Lunar)" : ("Druid", "Balance"),
            "Solar Beam": ("Druid", "Balance"),
            "Mangle": ("Druid", "Feral"),
            "Rake": ("Druid", "Feral"),
            "Shred": ("Druid", "Feral"),
            "Ferocious Bite": ("Druid", "Feral"),
            "Rip": ("Druid", "Feral"),
            "Maul": ("Druid", "Feral"),
            "Swipe": ("Druid", "Feral"),
            "Savage Defense": ("Druid", "Feral"),
            "Frenzied Regeneration": ("Druid", "Feral"),
            "Harmony": ("Druid", "Restoration"),
            "Lifebloom": ("Druid", "Restoration"),
            "Tree of Life": ("Druid", "Restoration"),
            "Swiftmend": ("Druid", "Restoration"),
            "Nature's Cure": ("Druid", "Restoration"),
            "Kill Command": ("Hunter", "Beast Mastery"),
            "Bestial Wrath": ("Hunter", "Beast Mastery"),
            "Intimidation": ("Hunter", "Beast Mastery"),
            "Ferocious Inspiration": ("Hunter", "Beast Mastery"),
            "Marked for Death": ("Hunter", "Marksmanship"),
            "Readiness": ("Hunter", "Marksmanship"),
            "Chimera Shot": ("Hunter", "Marksmanship"),
            "Trueshot Aura": ("Hunter", "Marksmanship"),
            "Explosive Shot": ("Hunter", "Survival"),
            "Black Arrow": ("Hunter", "Survival"),
            "Lock and Load": ("Hunter", "Survival"),
            "Wyvern Sting": ("Hunter", "Survival"),
            "Hunting Party": ("Hunter", "Survival"),
            "Arcane Blast": ("Mage", "Arcane"),
            "Slow": ("Mage", "Arcane"),
            "Arcane Tactics": ("Mage", "Arcane"),
            "Arcane Barrage": ("Mage", "Arcane"),
            "Presence of Mind": ("Mage", "Arcane"),
            "Arcane Power": ("Mage", "Arcane"),
            "Pyroblast": ("Mage", "Fire"),
            "Combustion": ("Mage", "Fire"),
            "Living Bomb": ("Mage", "Fire"),
            "Dragon's Breath": ("Mage", "Fire"),
            "Cauterize": ("Mage", "Fire"),
            "Blast Wave": ("Mage", "Fire"),
            "Deep Freeze": ("Mage", "Frost"),
            "Ice Barrier": ("Mage", "Frost"),
            "Fingers of Frost": ("Mage", "Frost"),
            "Holy Shock": ("Paladin", "Holy"),
            "Beacon of Light": ("Paladin", "Holy"),
            "Divine Light": ("Paladin", "Holy"),
            "Illuminated Healing": ("Paladin", "Holy"),
            "Hammer of the Righteous": ("Paladin", "Protection"),
            "Shield of the Righteous": ("Paladin", "Protection"),
            "Avenger's Shield": ("Paladin", "Protection"),
            "Ardent Defender": ("Paladin", "Protection"),
            "Divine Guardian": ("Paladin", "Protection"),
            "Crusader Strike": ("Paladin", "Retribution"),
            "Repentance": ("Paladin", "Retribution"),
            "Sacred Shield": ("Paladin", "Retribution"),
            "Templar's Verdict": ("Paladin", "Retribution"),
            "Divine Storm": ("Paladin", "Retribution"),
            "The Art of War": ("Paladin", "Retribution"),
            "Penance": ("Priest", "Discipline"),
            "Power Word: Shield": ("Priest", "Discipline"),
            "Divine Aegis": ("Priest", "Discipline"),
            "Borrowed Time": ("Priest", "Discipline"),
            "Grace": ("Priest", "Discipline"),
            "Pain Suppression": ("Priest", "Discipline"),
            "Power Infusion": ("Priest", "Discipline"),
            "Shadow Word: Pain": ("Priest", "Shadow"),
            "Vampiric Touch": ("Priest", "Shadow"),
            "Vampiric Embrace": ("Priest", "Shadow"),
            "Shadowform": ("Priest", "Shadow"),
            "Dispersion": ("Priest", "Shadow"),
            "Circle of Healing": ("Priest", "Holy"),
            "Spirit of Redemption": ("Priest", "Holy"),
            "Chakra": ("Priest", "Holy"),
            "Guardian Spirit": ("Priest", "Holy"),
            "Holy Word: Chastise": ("Priest", "Holy"),
            "Shadowstep": ("Rogue", "Subtlety"),
            "Honor Among Thieves": ("Rogue", "Subtlety"),
            "Hemorrhage": ("Rogue", "Subtlety"),
            "Premeditation": ("Rogue", "Subtlety"),
            "Shadow Dance": ("Rogue", "Subtlety"),
            "Sinister Strike": ("Rogue", "Combat"),
            "Blade Flurry": ("Rogue", "Combat"),
            "Savage Combat": ("Rogue", "Combat"),
            "Killing Spree": ("Rogue", "Combat"),
            "Adrenaline Rush": ("Rogue", "Combat"),
            "Mutilate": ("Rogue", "Assassination"),
            "Envenom": ("Rogue", "Assassination"),
            "Cold Blood": ("Rogue", "Assassination"),
            "Vendetta": ("Rogue", "Assassination"),
            "Elemental Oath": ("Shaman", "Elemental"),
            "Thunderstorm": ("Shaman", "Elemental"),
            "Elemental Mastery": ("Shaman", "Elemental"),
            "Earth Shield": ("Shaman", "Restoration"),
            "Riptide": ("Shaman", "Restoration"),
            "Spirit Link Totem": ("Shaman", "Restoration"),
            "Mana Tide Totem": ("Shaman", "Restoration"),
            "Stormstrike": ("Shaman", "Enhancement"),
            "Lava Lash": ("Shaman", "Enhancement"),
            "Feral Spirit": ("Shaman", "Enhancement"),
            "Maelstrom Weapon": ("Shaman", "Enhancement"),
            "Nightfall": ("Warlock", "Affliction"),
            "Unstable Affliction": ("Warlock", "Affliction"),
            "Haunt": ("Warlock", "Affliction"),
            "Soul Swap": ("Warlock", "Affliction"),
            "Conflagrate": ("Warlock", "Destruction"),
            "Chaos Bolt": ("Warlock", "Destruction"),
            "Shadowfury": ("Warlock", "Destruction"),
            "Shadowburn": ("Warlock", "Destruction"),
            "Nether Protection": ("Warlock", "Destruction"),
            "Demonic Pact": ("Warlock", "Demonology"),
            "Hand of Gul'dan": ("Warlock", "Demonology"),
            "Metamorphosis": ("Warlock", "Demonology"),
            "Mortal Strike": ("Warrior", "Arms"),
            "Throwdown": ("Warrior", "Arms"),
            "Bladestorm": ("Warrior", "Arms"),
            "Sudden Death": ("Warrior", "Arms"),
            "Taste for Blood": ("Warrior", "Arms"),
            "Bloodthirst": ("Warrior", "Fury"),
            "Raging Blow": ("Warrior", "Fury"),
            "Rampage": ("Warrior", "Fury"),
            "Death Wish": ("Warrior", "Fury"),
            "Shield Slam": ("Warrior", "Protection"),
            "Revenge": ("Warrior", "Protection"),
            "Devastate": ("Warrior", "Protection"),
            "Vigilance": ("Warrior", "Protection"),
            "Shockwave": ("Warrior", "Protection"),
            "Last Stand": ("Warrior", "Protection")
            }

        for log_line in game_log:
            parts = log_line.split(',')
            if ('SPELL_AURA_APPLIED' in parts[0] or 'SPELL_CAST_SUCCESS' in parts[0] or 'SPELL_CAST_START' in parts[0]) and parts[1] == player_id:
                lookup = spell_dict.get(parts[10].strip('"'))
                if lookup:
                    inferred_class, inferred_spec = lookup
                    return inferred_class, inferred_spec
                    

        return inferred_class, inferred_spec
    
    game = match(file_name,log_path)

    #First log the arena log processing time:
    game.log_process_timestamp = datetime.now().timestamp()

    #Get match start time by taking the timestamp of the first event and adding 30 seconds
    game.match_start_time = get_timestamp_from_log_line(game_log[0]) + timedelta(seconds=30)

    #Determine the final death event to occur in the log by going through the log backwards:
    for line in reversed(game_log):
        parts = line.split(',')
        if 'UNIT_DIED' in parts[0] and 'Player-' in parts[5]:
            game.last_death_event = line #Save the last death event to determine winner later
            game.match_end_time = get_timestamp_from_log_line(line) #Mark match end time
            game.match_length = int((game.match_end_time - game.match_start_time).total_seconds())
            break

    #Get players dict for this game:
    game.players = extract_players(game_log)

    #Use the length of game.players to determine the game type
    if len(game.players) <= 4:
        game.game_type = "2v2"
    elif len(game.players) <= 6:
        game.game_type = "3v3"
    elif len(game.players) <= 10:
        game.game_type = "5v5"
    else:
        game.type = "ERROR"

    #Get teams using the players dict
    game.team_1, game.team_2 = extract_teams(game.players,game_log)

    #Now that we have teams, lets determine the winning team using the last_death_event, this is trash code
    if game.last_death_event != None:
        for participant in game.team_1:
            if participant.player_id in game.last_death_event:
                game.winner = "team_2"
                for participant in game.team_2:
                    participant.winner = True

        for participant in game.team_2:
             if participant.player_id in game.last_death_event:
                game.winner = "team_1"
                for participant in game.team_1:
                    participant.winner = True
    else:
        print("No last death event found for game: " + game.combat_log)

    return game

#Function used to process in cloud
def process_game_file(event, context):
    client = storage.Client()
    bucket_name = event['bucket']
    file_name = event['name']
    file_path = f"gs://{bucket_name}/{file_name}"
    
    input_bucket = client.bucket(bucket_name)
    blob = input_bucket.blob(file_name)
    content = blob.download_as_text().splitlines()

    # Initialize and process game data
    match = process_arena_log(content,file_name,file_path)

    # Write processed data to BigQuery
    bq_client = bigquery.Client()
    table_id = 'cata-colosseum.cata_colosseum_beta.cata-colosseum_arena_matches'
    
    errors = bq_client.insert_rows_json(table_id, [match.to_dict()])
    if errors:
        print(f"Encountered errors while inserting rows: {errors} Arena Match File: {match.combat_log}" )
    else:
        print(f"Successfully inserted match {match.match_id} into BigQuery")